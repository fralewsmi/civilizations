<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Civilizations — Geographic Streams Timeline</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Cinzel:wght@400;600&family=EB+Garamond:ital,wght@0,400;1,400&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <header>
      <h1>Empires of the <em>Ancient &amp; Modern World</em></h1>
      <p class="subtitle">
        Six geographic streams · bar height proportional to each civilisation's
        duration · hover to explore
      </p>
      <div class="hdiv"></div>
    </header>

    <div class="legend" id="legend"></div>

    <div id="chart-outer">
      <canvas id="c"></canvas>
    </div>

    <div id="tt">
      <div class="tn"></div>
      <div class="td"></div>
      <div class="tb"></div>
      <div class="tg"></div>
      <div class="tc">
        <div class="tc-label">Further Reading</div>
        <div class="tc-items"></div>
      </div>
    </div>

    <footer>
      Bar height is proportional to each civilisation's duration. Each
      geographic stream represents a region of the world — hover any bar to
      explore dates, context, and key achievements.
    </footer>

    <!-- ══════════════════════════════════════════════
     REFERENCES & FURTHER READING
══════════════════════════════════════════════ -->
    <section id="references">
      <div class="ref-header">
        <span class="eyebrow">Scholarship & Sources</span>
        <h2>References &amp; <em>Further Reading</em></h2>
      </div>

      <div class="ref-grid" id="ref-grid"></div>

      <!-- General / Cross-civilisation resources -->
      <div class="general-resources">
        <h3>Cross-civilisation &amp; General Resources</h3>
        <div class="res-grid" id="res-grid"></div>
      </div>

      <p class="note">
        Dates for ancient civilisations are approximate and subject to ongoing
        scholarly revision.<br />
        Where sources disagree, ranges represent the most widely accepted
        academic consensus as of 2024.
      </p>
    </section>

    <script>
      // ── Reference data ─────────────────────────────────────
      // Only entries with a direct relationship to civilisations shown in the chart.
      const REF_DATA = []; // data.json

      // ── Render references ──────────────────────────────────
      const refGrid = document.getElementById("ref-grid");
      REF_DATA.forEach((group) => {
        const div = document.createElement("div");
        div.className = "ref-group";
        div.innerHTML = `
    <div class="ref-group-header" onclick="this.parentElement.classList.toggle('open')">
      <div class="ref-swatch" style="background:${group.col}"></div>
      <div class="ref-group-title">${group.region}</div>
      <div class="ref-toggle">▾</div>
    </div>
    <div class="ref-list">
      ${group.refs
        .map(
          (r) => `
        <div class="ref-item">
          <div class="ref-item-top">
            <span class="ref-type">${r.type}</span>
            <span class="ref-title">${r.url ? `<a href="${r.url}" target="_blank" rel="noopener">${r.title}</a>` : r.title}</span>
          </div>
          <div class="ref-meta">${r.author} — ${r.note}</div>
        </div>`,
        )
        .join("")}
    </div>`;
        // Open first two by default
        if (REF_DATA.indexOf(group) < 2) div.classList.add("open");
        refGrid.appendChild(div);
      });

      const resGrid = document.getElementById("res-grid");
    </script>

    <script>
      const REGIONS = []; // data.json

      const CIVS = []; // data.json

      // ── Legend ─────────────────────────────────────
      const legendEl = document.getElementById("legend");
      REGIONS.forEach((r) => {
        const d = document.createElement("div");
        d.className = "leg-item";
        d.innerHTML = `<div class="leg-swatch" style="background:${r.col}"></div><span>${r.label.replace("\n", " ")}</span>`;
        legendEl.appendChild(d);
      });

      // ── Canvas setup ───────────────────────────────
      const canvas = document.getElementById("c");
      const ctx = canvas.getContext("2d");
      const tt = document.getElementById("tt");

      const T_START = -3600;
      const T_END = 2026;
      const T_SPAN = T_END - T_START;
      const CANVAS_H = 3000;
      const M_TOP = 100;
      const M_BOT = 60;
      const CHART_H = CANVAS_H - M_TOP - M_BOT;
      const AXIS_W = 58;
      const LANE_PAD = 8;
      const BAR_GAP = 4;
      const MIN_BAR_W = 38;

      function yearToY(y) {
        return M_TOP + ((y - T_START) / T_SPAN) * CHART_H;
      }

      function maxParallel(rid) {
        const civs = CIVS.filter((c) => c.region === rid);
        if (!civs.length) return 1;
        const evts = [];
        civs.forEach((c) => {
          evts.push([c.start, 1]);
          evts.push([c.end, -1]);
        });
        evts.sort((a, b) => a[0] - b[0] || a[1] - b[1]);
        let cur = 0,
          mx = 0;
        evts.forEach(([, d]) => {
          cur += d;
          if (cur > mx) mx = cur;
        });
        return Math.max(mx, 1);
      }

      const maxCols = Math.max(...REGIONS.map((r) => maxParallel(r.id)));
      const EQUAL_LANE_W = maxCols * (MIN_BAR_W + BAR_GAP) + LANE_PAD * 2;
      const laneWidths = REGIONS.map(() => EQUAL_LANE_W);

      function laneX(i) {
        let x = AXIS_W;
        for (let j = 0; j < i; j++) x += laneWidths[j];
        return x;
      }

      const TOTAL_W = laneWidths.reduce((a, b) => a + b, 0);
      const CANVAS_W = AXIS_W + TOTAL_W + 10;

      let hitBoxes = [];

      function hexRgb(hex) {
        return {
          r: parseInt(hex.slice(1, 3), 16),
          g: parseInt(hex.slice(3, 5), 16),
          b: parseInt(hex.slice(5, 7), 16),
        };
      }

      function rRect(x, y, w, h, r) {
        r = Math.min(r, w / 2, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r);
        ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r);
        ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
      }

      function draw() {
        canvas.width = CANVAS_W;
        canvas.height = CANVAS_H;

        // Background
        ctx.fillStyle = "#08070a";
        ctx.fillRect(0, 0, CANVAS_W, CANVAS_H);

        // Year axis ticks
        const ticks = [];
        for (let y = -3500; y <= 2000; y += 250) ticks.push(y);
        ticks.forEach((yr) => {
          const cy = yearToY(yr);
          const major = yr % 500 === 0;

          ctx.strokeStyle = major
            ? "rgba(212,168,50,0.12)"
            : "rgba(212,168,50,0.05)";
          ctx.lineWidth = 1;
          ctx.setLineDash(major ? [4, 8] : [2, 12]);
          ctx.beginPath();
          ctx.moveTo(AXIS_W, cy);
          ctx.lineTo(CANVAS_W - 4, cy);
          ctx.stroke();
          ctx.setLineDash([]);

          if (major) {
            ctx.fillStyle = "rgba(212,168,50,0.5)";
            ctx.font = "600 9px Cinzel, serif";
            ctx.textAlign = "right";
            ctx.textBaseline = "middle";
            const lbl =
              yr < 0 ? `${Math.abs(yr)} BCE` : yr === 0 ? "1 CE" : `${yr} CE`;
            ctx.fillText(lbl, AXIS_W - 6, cy);
          }
        });

        // Lane backgrounds + headers
        REGIONS.forEach((region, i) => {
          const lx = laneX(i);
          const lw = laneWidths[i];
          const cx = lx + lw / 2;

          // subtle alternating fill
          ctx.fillStyle =
            i % 2 === 0 ? "rgba(255,255,255,0.014)" : "transparent";
          ctx.fillRect(lx, 0, lw, CANVAS_H);

          // separator line
          if (i > 0) {
            ctx.strokeStyle = "rgba(212,168,50,0.1)";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(lx, 70);
            ctx.lineTo(lx, CANVAS_H - M_BOT);
            ctx.stroke();
          }

          // header box
          const rgb = hexRgb(region.col);
          ctx.fillStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},0.18)`;
          ctx.fillRect(lx, 0, lw, 68);

          // header bottom accent
          ctx.fillStyle = `rgba(${rgb.r},${rgb.g},${rgb.b},0.6)`;
          ctx.fillRect(lx, 65, lw, 2);

          // header text
          ctx.fillStyle = `rgba(${rgb.r + 60},${rgb.g + 60},${rgb.b + 60},1)`;
          ctx.font = "600 9.5px Cinzel, serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          const lines = region.label.split("\n");
          const lineH = 14;
          const startY = 34 - ((lines.length - 1) * lineH) / 2;
          lines.forEach((ln, li) => ctx.fillText(ln, cx, startY + li * lineH));
        });

        // Draw bars
        hitBoxes = [];

        REGIONS.forEach((region, ri) => {
          const lx = laneX(ri) + LANE_PAD;
          const lw = laneWidths[ri] - LANE_PAD * 2;
          const civs = CIVS.filter((c) => c.region === region.id).sort(
            (a, b) => a.start - b.start,
          );

          // Greedy column packing
          const cols = [];
          civs.forEach((civ) => {
            let placed = false;
            for (let ci = 0; ci < cols.length; ci++) {
              if (civ.start >= cols[ci][cols[ci].length - 1].end - 30) {
                cols[ci].push(civ);
                placed = true;
                break;
              }
            }
            if (!placed) cols.push([civ]);
          });

          const nc = cols.length || 1;
          const barW = (lw - BAR_GAP * (nc - 1)) / nc;

          cols.forEach((col, ci) => {
            const bx = lx + ci * (barW + BAR_GAP);
            col.forEach((civ) => {
              const by = yearToY(civ.start);
              const ey = yearToY(civ.end);
              const bh = Math.max(ey - by, 7);

              const rgb = hexRgb(region.col);
              const lg = ctx.createLinearGradient(bx, by, bx + barW, by + bh);
              lg.addColorStop(
                0,
                `rgba(${rgb.r + 55},${rgb.g + 55},${rgb.b + 55},0.78)`,
              );
              lg.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},0.5)`);

              ctx.fillStyle = lg;
              rRect(bx, by, barW, bh, 2);
              ctx.fill();

              // Border
              ctx.strokeStyle = `rgba(${rgb.r + 100},${rgb.g + 100},${rgb.b + 100},0.28)`;
              ctx.lineWidth = 0.75;
              rRect(bx, by, barW, bh, 2);
              ctx.stroke();

              // Top glow
              ctx.fillStyle = `rgba(${rgb.r + 140},${rgb.g + 140},${rgb.b + 140},0.45)`;
              ctx.fillRect(bx + 2, by, barW - 4, 1.5);

              // Rotated name
              if (bh > 16) {
                ctx.save();
                ctx.translate(bx + barW / 2, by + bh / 2);
                ctx.rotate(-Math.PI / 2);
                const fs = Math.min(11, Math.max(7, barW * 0.36));
                ctx.font = `italic ${fs}px EB Garamond, serif`;
                ctx.fillStyle = "rgba(240,230,200,0.92)";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                let lbl = civ.name;
                const maxPx = bh - 10;
                while (
                  ctx.measureText(lbl + "…").width > maxPx &&
                  lbl.length > 2
                )
                  lbl = lbl.slice(0, -1);
                if (lbl !== civ.name) lbl += "…";
                ctx.fillText(lbl, 0, 0);
                ctx.restore();
              }

              hitBoxes.push({
                x1: bx,
                y1: by,
                x2: bx + barW,
                y2: by + bh,
                civ,
              });
            });
          });
        });

        // Bottom axis label
        ctx.fillStyle = "rgba(212,168,50,0.35)";
        ctx.font = "600 9px Cinzel, serif";
        ctx.textAlign = "center";
        ctx.fillText(
          "2026 CE  ·  PRESENT",
          AXIS_W + TOTAL_W / 2,
          CANVAS_H - 20,
        );
      }

      // ── Tooltip ───────────────────────────────────
      canvas.addEventListener("mousemove", (e) => {
        const rect = canvas.getBoundingClientRect();
        const sx = canvas.width / rect.width;
        const sy = canvas.height / rect.height;
        const mx = (e.clientX - rect.left) * sx;
        const my = (e.clientY - rect.top) * sy;

        let hit = null;
        for (const hb of hitBoxes) {
          if (mx >= hb.x1 && mx <= hb.x2 && my >= hb.y1 && my <= hb.y2) {
            hit = hb.civ;
            break;
          }
        }

        if (hit) {
          canvas.style.cursor = "pointer";
          const sl =
            hit.start < 0 ? `${Math.abs(hit.start)} BCE` : `${hit.start} CE`;
          const el =
            hit.end >= 2025
              ? "Present"
              : hit.end < 0
                ? `${Math.abs(hit.end)} BCE`
                : `${hit.end} CE`;
          const dur = hit.end - hit.start;
          tt.querySelector(".tn").textContent = hit.name;
          tt.querySelector(".td").textContent =
            `${sl} – ${el}  ·  c.${dur} years`;
          tt.querySelector(".tb").textContent = hit.desc;
          tt.querySelector(".tg").innerHTML = hit.tags
            .map((t) => `<span>${t}</span>`)
            .join("");
          const tcEl = tt.querySelector(".tc");
          const tcItems = tt.querySelector(".tc-items");
          if (hit.refs && hit.refs.length) {
            tcItems.innerHTML = hit.refs
              .map(
                (r) =>
                  `<div class="tc-item"><a href="${r.url}" target="_blank" rel="noopener">${r.title}</a> — ${r.author}</div>`,
              )
              .join("");
            tcEl.style.display = "block";
          } else {
            tcEl.style.display = "none";
          }
          let tx = e.clientX + 18,
            ty = e.clientY - 12;
          if (tx + 310 > window.innerWidth) tx = e.clientX - 308;
          if (ty + 230 > window.innerHeight) ty = e.clientY - 230;
          tt.style.left = tx + "px";
          tt.style.top = ty + "px";
          tt.classList.add("show");
        } else {
          canvas.style.cursor = "crosshair";
          tt.classList.remove("show");
        }
      });
      canvas.addEventListener("mouseleave", () => tt.classList.remove("show"));

      draw();
    </script>
  </body>
</html>
